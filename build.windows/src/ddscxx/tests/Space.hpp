/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: Space.idl
  Source: Space.hpp
  Cyclone DDS: v0.8.0

*****************************************************************/
#ifndef DDSCXX_SPACE_HPP
#define DDSCXX_SPACE_HPP

namespace Space
{
enum class Enumeration
{
  VALUE1,
  VALUE2};

class Type1
{
private:
 int32_t long_1_ = 0;
 int32_t long_2_ = 0;
 int32_t long_3_ = 0;

public:
  Type1() = default;

  explicit Type1(
    int32_t long_1,
    int32_t long_2,
    int32_t long_3) :
    long_1_(long_1),
    long_2_(long_2),
    long_3_(long_3) { }

  int32_t long_1() const { return this->long_1_; }
  int32_t& long_1() { return this->long_1_; }
  void long_1(int32_t _val_) { this->long_1_ = _val_; }
  int32_t long_2() const { return this->long_2_; }
  int32_t& long_2() { return this->long_2_; }
  void long_2(int32_t _val_) { this->long_2_ = _val_; }
  int32_t long_3() const { return this->long_3_; }
  int32_t& long_3() { return this->long_3_; }
  void long_3(int32_t _val_) { this->long_3_ = _val_; }

  bool operator==(const Type1& _other) const
  {
    return long_1_ == _other.long_1_ &&
      long_2_ == _other.long_2_ &&
      long_3_ == _other.long_3_;
  }

  bool operator!=(const Type1& _other) const
  {
    return !(*this == _other);
  }

};

class Type2
{
private:
 int32_t long_1_ = 0;
 int32_t long_2_ = 0;
 int32_t long_3_ = 0;
 ::Space::Enumeration enum_1_ = ::Space::Enumeration::VALUE1;

public:
  Type2() = default;

  explicit Type2(
    int32_t long_1,
    int32_t long_2,
    int32_t long_3,
    ::Space::Enumeration enum_1) :
    long_1_(long_1),
    long_2_(long_2),
    long_3_(long_3),
    enum_1_(enum_1) { }

  int32_t long_1() const { return this->long_1_; }
  int32_t& long_1() { return this->long_1_; }
  void long_1(int32_t _val_) { this->long_1_ = _val_; }
  int32_t long_2() const { return this->long_2_; }
  int32_t& long_2() { return this->long_2_; }
  void long_2(int32_t _val_) { this->long_2_ = _val_; }
  int32_t long_3() const { return this->long_3_; }
  int32_t& long_3() { return this->long_3_; }
  void long_3(int32_t _val_) { this->long_3_ = _val_; }
  ::Space::Enumeration enum_1() const { return this->enum_1_; }
  ::Space::Enumeration& enum_1() { return this->enum_1_; }
  void enum_1(::Space::Enumeration _val_) { this->enum_1_ = _val_; }

  bool operator==(const Type2& _other) const
  {
    return long_1_ == _other.long_1_ &&
      long_2_ == _other.long_2_ &&
      long_3_ == _other.long_3_ &&
      enum_1_ == _other.enum_1_;
  }

  bool operator!=(const Type2& _other) const
  {
    return !(*this == _other);
  }

};

}

#include "org/eclipse/cyclonedds/topic/TopicTraits.hpp"
#include "org/eclipse/cyclonedds/topic/DataRepresentation.hpp"

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {
template <>
class TopicTraits<::Space::Type1>
{
public:
  static ::org::eclipse::cyclonedds::topic::DataRepresentationId_t getDataRepresentationId()
  {
    return ::org::eclipse::cyclonedds::topic::OSPL_REPRESENTATION;
  }

  static ::std::vector<uint8_t> getMetaData()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getTypeHash()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getExtentions()
  {
    return ::std::vector<uint8_t>();
  }

  static bool isKeyless()
  {
    return false;
  }

  static const char *getTypeName()
  {
    return "Space::Type1";
  }

  static ddsi_sertype *getSerType()
  {
    auto *st = new ddscxx_sertype<::Space::Type1>();
    return static_cast<ddsi_sertype*>(st);
  }

  static size_t getSampleSize()
  {
    return sizeof(::Space::Type1);
  }
};
}
}
}
}

namespace dds {
namespace topic {
template <>
struct topic_type_name<::Space::Type1>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::Space::Type1>::getTypeName();
    }
};
}
}

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {
template <>
class TopicTraits<::Space::Type2>
{
public:
  static ::org::eclipse::cyclonedds::topic::DataRepresentationId_t getDataRepresentationId()
  {
    return ::org::eclipse::cyclonedds::topic::OSPL_REPRESENTATION;
  }

  static ::std::vector<uint8_t> getMetaData()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getTypeHash()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getExtentions()
  {
    return ::std::vector<uint8_t>();
  }

  static bool isKeyless()
  {
    return false;
  }

  static const char *getTypeName()
  {
    return "Space::Type2";
  }

  static ddsi_sertype *getSerType()
  {
    auto *st = new ddscxx_sertype<::Space::Type2>();
    return static_cast<ddsi_sertype*>(st);
  }

  static size_t getSampleSize()
  {
    return sizeof(::Space::Type2);
  }
};
}
}
}
}

namespace dds {
namespace topic {
template <>
struct topic_type_name<::Space::Type2>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::Space::Type2>::getTypeName();
    }
};
}
}

REGISTER_TOPIC_TYPE(::Space::Type1)
REGISTER_TOPIC_TYPE(::Space::Type2)

template<typename T>
void write(T& str, const ::Space::Type1& instance)
{
  write(str, instance.long_1());
  write(str, instance.long_2());
  write(str, instance.long_3());
}
template<typename T>
void write(T& str, const ::Space::Type2& instance)
{
  write(str, instance.long_1());
  write(str, instance.long_2());
  write(str, instance.long_3());
  write(str, instance.enum_1());
}

template<typename T>
void read(T& str, ::Space::Type1& instance)
{
  read(str, instance.long_1());
  read(str, instance.long_2());
  read(str, instance.long_3());
}
template<typename T>
void read(T& str, ::Space::Type2& instance)
{
  read(str, instance.long_1());
  read(str, instance.long_2());
  read(str, instance.long_3());
  read(str, instance.enum_1());
}

template<typename T>
void move(T& str, const ::Space::Type1& instance)
{
  move(str, instance.long_1());
  move(str, instance.long_2());
  move(str, instance.long_3());
}
template<typename T>
void move(T& str, const ::Space::Type2& instance)
{
  move(str, instance.long_1());
  move(str, instance.long_2());
  move(str, instance.long_3());
  move(str, instance.enum_1());
}

template<typename T>
void max(T& str, const ::Space::Type1& instance)
{
  max(str, instance.long_1());
  max(str, instance.long_2());
  max(str, instance.long_3());
}
template<typename T>
void max(T& str, const ::Space::Type2& instance)
{
  max(str, instance.long_1());
  max(str, instance.long_2());
  max(str, instance.long_3());
  max(str, instance.enum_1());
}

template<typename T>
void key_write(T& str, const ::Space::Type1& instance)
{
  write(str, instance.long_1());
}
template<typename T>
void key_write(T& str, const ::Space::Type2& instance)
{
  write(str, instance.long_1());
}

template<typename T>
void key_read(T& str, ::Space::Type1& instance)
{
  read(str, instance.long_1());
}
template<typename T>
void key_read(T& str, ::Space::Type2& instance)
{
  read(str, instance.long_1());
}

template<typename T>
void key_move(T& str, const ::Space::Type1& instance)
{
  move(str, instance.long_1());
}
template<typename T>
void key_move(T& str, const ::Space::Type2& instance)
{
  move(str, instance.long_1());
}

template<typename T>
void key_max(T& str, const ::Space::Type1& instance)
{
  max(str, instance.long_1());
}
template<typename T>
void key_max(T& str, const ::Space::Type2& instance)
{
  max(str, instance.long_1());
}
#endif // DDSCXX_SPACE_HPP
