/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: HelloWorldData.idl
  Source: HelloWorldData.hpp
  Cyclone DDS: v0.8.0

*****************************************************************/
#ifndef DDSCXX_HELLOWORLDDATA_HPP
#define DDSCXX_HELLOWORLDDATA_HPP

#include <org/eclipse/cyclonedds/topic/cdr_dummys.hpp>

namespace HelloWorldData
{
class Msg
{
private:
 int32_t userID_ = 0;
 idl_string<0> message_;

public:
  Msg() = default;

  explicit Msg(
    int32_t userID,
    const idl_string<0>& message) :
    userID_(userID),
    message_(message) { }

  int32_t userID() const { return this->userID_; }
  int32_t& userID() { return this->userID_; }
  void userID(int32_t _val_) { this->userID_ = _val_; }
  const idl_string<0> message() const { return this->message_; }
  idl_string<0>& message() { return this->message_; }
  void message(const idl_string<0> _val_) { this->message_ = _val_; }
  void message(idl_string<0>&& _val_) { this->message_ = _val_; }

  bool operator==(const Msg& _other) const
  {
    return userID_ == _other.userID_ &&
      message_ == _other.message_;
  }

  bool operator!=(const Msg& _other) const
  {
    return !(*this == _other);
  }

};

}

#include "org/eclipse/cyclonedds/topic/TopicTraits.hpp"
#include "org/eclipse/cyclonedds/topic/DataRepresentation.hpp"

namespace org {
namespace eclipse {
namespace cyclonedds {
namespace topic {
template <>
class TopicTraits<::HelloWorldData::Msg>
{
public:
  static ::org::eclipse::cyclonedds::topic::DataRepresentationId_t getDataRepresentationId()
  {
    return ::org::eclipse::cyclonedds::topic::OSPL_REPRESENTATION;
  }

  static ::std::vector<uint8_t> getMetaData()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getTypeHash()
  {
    return ::std::vector<uint8_t>();
  }

  static ::std::vector<uint8_t> getExtentions()
  {
    return ::std::vector<uint8_t>();
  }

  static bool isKeyless()
  {
    return false;
  }

  static const char *getTypeName()
  {
    return "HelloWorldData::Msg";
  }

  static ddsi_sertype *getSerType()
  {
    auto *st = new ddscxx_sertype<::HelloWorldData::Msg>();
    return static_cast<ddsi_sertype*>(st);
  }

  static size_t getSampleSize()
  {
    return sizeof(::HelloWorldData::Msg);
  }
};
}
}
}
}

namespace dds {
namespace topic {
template <>
struct topic_type_name<::HelloWorldData::Msg>
{
    static std::string value()
    {
      return org::eclipse::cyclonedds::topic::TopicTraits<::HelloWorldData::Msg>::getTypeName();
    }
};
}
}

REGISTER_TOPIC_TYPE(::HelloWorldData::Msg)

template<typename T>
void write(T& str, const ::HelloWorldData::Msg& instance)
{
  write(str, instance.userID());
  write(str, instance.message());
}

template<typename T>
void read(T& str, ::HelloWorldData::Msg& instance)
{
  read(str, instance.userID());
  read(str, instance.message());
}

template<typename T>
void move(T& str, const ::HelloWorldData::Msg& instance)
{
  move(str, instance.userID());
  move(str, instance.message());
}

template<typename T>
void max(T& str, const ::HelloWorldData::Msg& instance)
{
  max(str, instance.userID());
  max(str, instance.message());
}

template<typename T>
void key_write(T& str, const ::HelloWorldData::Msg& instance)
{
  write(str, instance.userID());
}

template<typename T>
void key_read(T& str, ::HelloWorldData::Msg& instance)
{
  read(str, instance.userID());
}

template<typename T>
void key_move(T& str, const ::HelloWorldData::Msg& instance)
{
  move(str, instance.userID());
}

template<typename T>
void key_max(T& str, const ::HelloWorldData::Msg& instance)
{
  max(str, instance.userID());
}
#endif // DDSCXX_HELLOWORLDDATA_HPP
